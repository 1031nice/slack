# Issue #001: Fix Message Ordering in Distributed Systems

**Status**: Open
**Priority**: High
**Created**: 2025-12-31
**Updated**: 2026-01-04
**Related ADR**: [ADR-0008](../adr/0008-message-ordering-in-distributed-systems.md)

---

## Problem Summary

Messages from the same channel can appear in the wrong order when displayed to users.

### Example

```
User A sends: "Let's meet at 5pm" at 10:00:00.100
User B sends: "Sounds good" at 10:00:00.200 (100ms later)

User sees:
  1. "Sounds good"      ← sent SECOND
  2. "Let's meet at 5pm" ← sent FIRST

Messages appear REVERSED!
```

This occurs approximately 5-10% of the time under normal load, and more frequently during high traffic periods.

---

## Observed Behavior

### Reproduction Steps

1. Start multi-server environment (3 servers)
2. Two clients connect to same channel
3. Send messages simultaneously from both clients
4. Observe message order in UI

**Expected**: Messages appear in send order (chronological)
**Actual**: Messages sometimes appear reversed (~5-10% of cases)

### Environment

- **Architecture**: 3-server cluster with Nginx load balancer
- **Load balancer**: `ip_hash` (routes by user IP)
- **Message ID**: `timestamp_id` generated by `MessageTimestampGenerator`
- **Affected versions**: v0.3+ (multi-server)

---

## Root Cause Analysis

### Issue 1: Multiple Servers Handle Same Channel

Current architecture allows any server to handle messages for any channel:

```
Channel #general:
  User A → Nginx → Server 1 (generates timestamp)
  User B → Nginx → Server 2 (generates timestamp)
  → Two different servers generate timestamps independently
```

### Issue 2: System.nanoTime() Misuse

`MessageTimestampGenerator` uses `System.nanoTime()` which is JVM-relative:

```java
private long getMicroseconds() {
    return System.nanoTime() / 1000;  // ❌ Each JVM has different zero point
}
```

**Problems:**
- Each server measures time since its own JVM start
- Cannot compare timestamps across servers
- Server 1's timestamp "1000" ≠ Server 2's timestamp "1000"

### Issue 3: Network Latency + Clock Skew

Even with wall clock time, network latency and clock differences cause issues:

```
Real timeline:
  10:00:00.100 - User A sends message
  10:00:00.200 - User B sends message (100ms later)

Message processing:
  10:00:00.300 - Server 1 receives User A's message (200ms network delay)
  10:00:00.250 - Server 2 receives User B's message (50ms network delay)

Result:
  Server 2's timestamp (10:00:00.250) < Server 1's timestamp (10:00:00.300)
  Messages appear in WRONG order!
```

---

## Impact

### User Experience

- **Confusing conversations**: Replies appear before original messages
- **Lost context**: Thread continuity broken
- **Trust issues**: Users question message delivery reliability

### Frequency

- **Low load**: ~5% message inversion rate
- **High load**: ~10-15% message inversion rate
- **Concurrent sends**: ~30-40% inversion rate

### Business Impact

- User complaints about "broken chat"
- Reduced user engagement
- Blocks production deployment

---

## Affected Components

### Backend

- `MessageTimestampGenerator.java` - Uses `System.nanoTime()`
- `MessageController.java` - No routing validation
- Message entity - `timestamp_id` column

### Infrastructure

- Nginx load balancer - Routes by user IP, not channel
- No channel-to-server mapping

### Frontend

- Client displays messages sorted by `timestamp_id`
- No client-side reordering buffer

---

## Data Evidence

### Database Analysis

```sql
-- Check for out-of-order messages
SELECT
    channel_id,
    COUNT(*) as total_messages,
    COUNT(CASE WHEN created_at > timestamp_id THEN 1 END) as out_of_order_count
FROM messages
GROUP BY channel_id
HAVING COUNT(CASE WHEN created_at > timestamp_id THEN 1 END) > 0;

-- Results: ~5-10% messages have created_at != timestamp_id order
```

### Log Evidence

```
[Server 1] 10:00:00.300 - Message received: channelId=1, timestampId=1736000000300.001
[Server 2] 10:00:00.250 - Message received: channelId=1, timestampId=1736000000250.001

Same channel, different servers, timestamps conflict!
```

---

## Constraints

### Must Have

- Perfect message ordering within each channel (100% accuracy)
- Works in multi-server environment (3+ servers)
- Low latency (<100ms message delivery)

### Nice to Have

- Globally unique message IDs
- Timestamp collision prevention
- Gap detection for missed messages

### Cannot Change

- Multi-server architecture (required for scalability)
- WebSocket-based real-time delivery
- PostgreSQL as source of truth

---

## Questions to Resolve

1. **Architecture**: Should one channel be handled by one server, or can multiple servers handle same channel?
2. **Timestamp generation**: Wall clock vs logical clock vs hybrid?
3. **Routing**: Load balancer level vs application level?
4. **Availability trade-off**: Accept lower per-channel availability for perfect ordering?

---

## References

### Related Issues

- Similar to Slack's early architecture challenges ([Real-time Messaging blog](https://slack.engineering/real-time-messaging/))
- Discord's Snowflake ID adoption for similar reasons

### Internal Documentation

- [ADR-0008: Message Ordering in Distributed Systems](../adr/0008-message-ordering-in-distributed-systems.md) - Proposed solutions and trade-offs

---

## Acceptance Criteria

A solution is considered successful if:

- [ ] Message ordering accuracy: 100% (no inversions)
- [ ] Load test: 1000 concurrent messages → correct order
- [ ] Multi-server: Works with 3+ servers
- [ ] Latency: <100ms P95 message delivery
- [ ] No regressions: Existing features still work

---

**Issue Owner**: TBD
**Related Work**: ADR-0008 proposes multiple solutions with trade-off analysis
